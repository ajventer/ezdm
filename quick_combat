#!/usr/bin/python
#First version limited automation
import sys
import os
from simplejson import loads,dumps
from pprint import pprint
from random import randrange

characters=[]
monsters=[]

def calcmonsterdata(monster):
        hd=int(monster["hitdice"])
        thac0={1:20,2:20,3:19,4:19,5:18,6:18,7:17,8:17,9:16,10:16,11:15,12:15,13:14,14:14,15:13,16:13,17:12,18:12,19:11,20:11,
                21:10,22:10,23:9,24:9,25:8,26:8,27:7,28:7,29:6,30:6,31:5,32:5,33:4,34:4,35:3,36:3,37:2,38:2,39:1,40:1}[hd]
        monster["thac0"] = thac0
        monster["hp"] = rolldice(autorollm,hd,8) 


def savechar(idx):
        global characters
        cname=characters[idx]['name']
        f=open('character_sheets/%s.json' %cname,'w')
        f.write(dumps(characters[idx],indent=4))
        f.close()

def rolldice(auto=True,numdice=1,numsides=20,modifier=0):
        print
        if not auto:
                while true:
                        print "Roll a %sd%s dice:"
                        try:
                                return int(raw_input())
                        except:
                                print "Error you must enter a number"
        else:
                total=0
                for I in range(1,numdice +1):
                        roll=randrange(1,numsides,1)
                        print "Rolled %s %s-sided dice: %s" %(I,numsides,roll)
                        total=total+roll
                
                total+=modifier       
                print "Total rolled: %s (modifier %s)" % (total,modifier)
                print
                return total

def modifiers(character):
	ability_scores=loads(open('adnd2e/ability_scores.json','r').read())
	modifier={}
	cstr=character["str"]
	cdex=character["dex"]
	cwis=character["wis"]
	modifier["to_hit"]=int(character["weapon_mod_to_hit"])+int(ability_scores["str"][cstr]["hit"])
	modifier["dmg"]=int(character["weapon_mod_dmg"])+int(ability_scores["str"][cstr]["dmg"])
	if character["weapon_type"] == "misile":
		modifier["dmg"] += int(ability_scores["dex"][cdex]["missile"])
	modifier["def"]=int(ability_scores["dex"][cdex]["defense"])
	modifier['mdef']=int(ability_scores["wis"][cwis]["magic_defence"])
	return modifier

def atack_mods(atacker):
	selected_mods={}
	custom_mods={'Atacker on [h]igh ground':1,
					'Defender [i]nvisible':-4,
					'Defender [o]ff-balance':2,
					'Defender [s]tunned or prone':999,
					'Defender surpri[z]ed':+1,
					'Rea[r] attack':+2}
	if atacker["weapon_type"] == "misile":
		print "%s is using a misile weapon - please specify range [l]ong/[m]edium/[s]hort"
		mrange=raw_input()
		if 'l' in mrange:
			selected_mods['[l]ong range missile']=-5
		elif 'm' in mrange:
			selected_mods['[m]edium range misile']=-2
	more=True
	while more:
		print
		print
		print
		print "Active combat modifiers %s" %selected_mods.keys()
		print "To add a modifier type a [highlighted letter]"
		print "To remove a modifier type r [highlighted letter]"
		print "To add unique custom modifier type c [value]"
		print "When done type x"
		print "Available modifiers:" 
		pprint(custom_mods.keys())
		command=raw_input().lower()
		if command.startswith('x'):
			more=False
		elif command.startswith('a'):
			for k in custom_mods.keys():
				search='['+command.strip('a').lstrip().rstrip()+']'
				if search in k:
					selected_mods[k]=custom_mods[k]
		elif command.startswith('c'):
			value=int(command.strip('c').lstrip().rstrip())
			selected_mods['custom DM modifier [%s]' %command] = value
		elif command.startswith('r'):
			search='['+command.strip('r').lstrip().rstrip()+']'
			for k in selected_mods.keys():
				if search in k:
					del selected_mods[k]
	print
	print
	print

	return selected_mods

def is_a_hit(roll,thac0,ac,defmod,crithit,critfumble):
	if critfumble:
		return False
	if crithit:
		return True
	if roll >= thac0 - (ac - defmod):
		return True

def do_attack(attackerindex,targetindex,attackertype):
		global characters
		global monsters
		if attackertype=="monster":
			defender=characters[targetindex]
			cindex=targetindex
			atacker=monsters[attackerindex]
			mindex=attackerindex
			auto=autorollm
			defendertype="character"
		else:
			defender=monsters[targetindex]
			cindex=attackerindex
			mindex=targetindex
			atacker=characters[attackerindex]
			auto=autorollc
			defendertype="monster"
		monster=monsters[mindex]
		character=characters[cindex]
		
		amods=modifiers(atacker)
		dmods=modifiers(defender)
		
		print "%s tries to attack %s" %(atacker['name'],defender['name'])
		to_hit_mod=int(amods['to_hit'])
		extra_mods=atack_mods(atacker)
		for v in extra_mods.values():
			to_hit_mod += int(v)
		num_attacks=int(atacker["atacks_per_round"])
		atack_number=0
		def_alive=True
		while atack_number < num_attacks and def_alive:
			atack_number += 1
			print "Atack %s of %s" %(atack_number,num_attacks)
			roll=rolldice(auto,1,20,to_hit_mod)
			crithit=roll - to_hit_mod == 20
			if crithit: 
				print "Critical hit ! %s gets an extra attack" %atacker['name']
				num_attacks += 1
			critfumble=roll -to_hit_mod == 1
			if critfumble:
				print "Critical fumble by %s !" %atacker['name']
			if is_a_hit(roll,int(atacker['thac0']),int(defender['armor_class']),int(dmods['def']),crithit,critfumble):
				print "	The attack is successfull"
				if is_casting(targetindex,defendertype):
					interrupt_casting(targetindex,defendertype)
				#Calculate damage
				damage_modifier=amods['dmg']
				if atacker.has_key("hitdice"):
					hit_dice=int(atacker["hitdice"])
				else:
					hit_dice=int(atacker["level"])
				damage=rolldice(auto,hit_dice,8)
				print "Damage done %s" %damage
				hp=int(defender['hp'])
				hp -= damage
				if hp < 0:
					hp = 0
				defender['hp'] = hp
				if hp > 0:
					print "%s has only %s hitpoints left" %(defender["name"],hp)
				if hp == 0:
					print "%s is dead" %(defender["name"])
					def_alive=False
					if attackertype=="monster":
						#Update the character
						characters[cindex]=character
						#Save the updated character
						savechar(cindex)
						#Remove the character from the fight
						del characters[cindex]
					else:
						#Remove the monster from the fight
						del monsters[cindex]
					#Either way this fight ends here
					return
			else:
				print "	Missed"
		characters[cindex]=character
		monsters[mindex]=monster
		
		

def is_casting(index,playertype):
	global characters
	global monsters
	if  playertype=="monster":
		character=monsters[index]
	else:
		character=characters[index]
	return (character.has_key('casting')) and int(character['casting']) > 0


def do_cast(index,playertype):
	global characters
	global monsters
	if playertype=="monster":
		if  is_casting(index,playertype):
			monsters[index]['casting'] -=1
			if monsters[index]['casting'] > 0:
				print "%s continous to cast: %s rounds remaining" %(monsters[index]['name'],monsters[index]['casting'])
			else:
				print "%s has finished the spell." %monsters[index]['name']
				ability_scores=loads(open('adnd2e/ability_scores.json','r').read())
				wis=int(monsters[index]["wis"])
				failrate=int(ability_scores["wis"]["spell_failure"].split('%')[0])
				roll=rolldice(autorollm,1,100)
				if roll > failrate:
					print "Spell succeeds"
				else:
					print "Spell fails"
		else:                        
			print "%s casts a spell. How many rounds does it take ?" %monsters[index]['name']
			monsters[index]['casting']=int(raw_input())
	else:
		if is_casting(index,playertype):
			characters[index]['casting'] -=1
			if characters[index]['casting'] >0:
				print "%s continous to cast %s rounds remaining" %(characters[index]['name'],characters[index]['casting'])
			else:
				print "%s has finished the spell. You should roll to determine success" %characters[index]['name']
				wis=int(characters[index]["wis"])
				failrate=int(ability_scores["wis"]["spell_failure"].split('%')[0])
				roll=rolldice(autorollc,1,100)
				if roll > failrate:
					print "Spell succeeds"
				else:
					print "Spell fails"
		else:                        
			print "%s casts a spell. How many rounds does it take ?" %characters[index]['name']
			characters[index]['casting']=int(raw_input())

def interrupt_casting(index,playertype):
        if playertype == 'monster':
                print "%s spellcasting interrupted ! Spell has failed." %monsters[index]['name']
                monsters[index]['casting']=0
        else:
                print "%s spellcasting interrupted ! Spell has failed." %characters[index]['name']
                characters[index]['casting']=0                                


def do_round(playerindex,playertype):
        global monsters
        global characters
        if playertype == 'monster':
                name=monsters[playerindex]["name"]
        else:
                name=characters[playerindex]["name"]
        print "Player: %s - %s [F]lee,[A]ttack,[C]ast ?" %(name, playerindex)
        if is_casting(playerindex,playertype):
			print "Beware: player %s is still busy casting a spell - choose c to continue" %name
        action=raw_input().lower()
        if 'f' in action:
                if is_casting(playerindex,playertype):
                        interrupt_casting(playerindex,playertype)
                print "%s tries to flee ! Is it successful [y/n] ?"  %name
                if 'y' in raw_input():
                        if playertype == 'monster':
                                del monsters[playerindex]
                        else:
                                print "Saving character before fleeing"
                                savechar(playerindex)
                                del characters[playerindex]
                        print "Got away !"
        if 'c' in action:
                do_cast(playerindex,playertype)

        if 'a' in action:
                if is_casting(playerindex,playertype):
                        interrupt_casting(playerindex,playertype)
                print "Who does %s attack ?" %name
                if playertype == 'monster':
                        for c in characters:
                                print "%s: %s" %(characters.index(c),c["name"])
                                targetlist=characters

                else:
                        for c in monsters:
                                print "%s : %s" %(monsters.index(c),c["name"])
                                targetlist=monsters
                targetindex=int(raw_input())
                do_attack(playerindex,targetindex,playertype)


print "######################"
print "# EZDM: QuickCombat  #"
print "######################"


c='y'
print "Should computer roll dice for characters [y/n] ?"
autorollc='y' in raw_input()
print "Should computer roll dice for monsters [y/n] ?"
autorollm='y' in raw_input()
print "##Loading characters###"
while not 'n' in c.lower():
        print "Enter character name:"
        cname=raw_input()
        try:
                characters.append(loads(open('character_sheets/%s.json' %cname).read()))
        except Exception as e:
                print "Error loading character %s - did you type it right ?" %cname
                print e
        if len(characters) > 0:
                print
                print
                print "Characters loaded:"
                pprint(characters)
                print "Load another character [y/n] ?"
                c=raw_input()


print "###Loading Monsters###"
c='y'
while not 'n' in c.lower():
        print "Monster details:"
        print " Do you have a monster file saved ? [y/n]?"
        i=raw_input()
        if 'y' in i.lower():
                cont=False
                print "Enter monster name:"
                monstername=raw_input() 
                try:
                        monsters.append(loads(open('monsters/%s.json' %monstername).read()))
                except Exception as e:
                        print "Error loading monster %s" %monstername
                        print e
        else:
                print "Creating a new monster:"
                os.system('./mkmonster')
        if len(monsters) > 0:
                print "Monsters loaded:"
                calcmonsterdata(monsters[len(monsters)-1])
                pprint(monsters)
                print "Load another monster [y/n] ?"
                c=raw_input()


#Encounter loop
rounds=0
quit=False
while not quit:
	rounds+=1
	turns=rounds/10
	print 
	print
	print
	print "####Turn: %s, Round %s####" %(turns,rounds - (turns *10))
	print "Play another round [y/n] ?"
	if 'n' in raw_input().lower():
		quit=True
		for player in characters:
			savechar(characters.index(player))
	else:
		print "Rolling for initiative:"
		print "Rolling for players:"
		c_initiative=rolldice(autorollc,1,20)
		print "Rolling for monsters:"
		m_initiative=rolldice(autorollm,1,20)
		if c_initiative <= m_initiative:
			for player in characters:
				do_round(characters.index(player),'character')
				for player in monsters:
					do_round(monsters.index(player),'monster')
		else:
			for player in monsters:
				do_round(monsters.index(player),'monster')
			for player in characters:
				do_round(characters.index(player),'character')
		rounds +=1
		if len(monsters) == 0: 
			quit=True
			for player in characters:
				savechar(characters.index(player))
		if len(characters) == 0:
			quit=True

			
